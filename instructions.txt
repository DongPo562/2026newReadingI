prompt: 请总结设计文档，整理出程序的框架和关键细节，用纯文本输出

### **程序整体框架**

本程序是一个**智能语音跟读/复习辅助工具**，采用**前后端分离**的架构运行。

- **后端 (Backend)**：负责监听鼠标事件、捕获剪贴板文本、内录系统音频以及音频后处理。
- **前端 (Frontend)**：一个悬浮的 UI 窗口，用于管理和播放录制的音频文件，支持多种复习模式。

---

### **核心模块与功能细节**

### **1. 入口与配置**

- **启动方式**：通过 `start_app.bat` 脚本同时启动 `floating_ui.py` (前端) 和 `main.py` (后端)。
- **配置文件** (`config.ini`)：统一管理录音参数（静音阈值、时长）、UI 样式、播放模式及路径设置。

### **2. 后端核心 (`main.py`)**

- **事件监听**：使用 `pynput` 监听全局鼠标事件。
- **触发机制**：
    - **拖拽触发**：按下并移动鼠标超过 5 像素。
    - **双击触发**：两次点击间隔小于 0.5 秒。
- **任务流**：触发后依次执行 `剪贴板捕获` -> `文本处理` -> `音频录制`。

### **3. 剪贴板管理 (`clipboard_manager.py`)**

- **无感捕获流程**：
    1. 备份当前用户剪贴板内容。
    2. 模拟 `Ctrl+C` 复制选中文字。
    3. 读取新内容。
    4. 延时 0.5s 后将原剪贴板内容恢复，减少对用户的干扰。

### **4. 文本处理 (`text_processor.py`)**

- **清洗规则**：仅保留英文字母、空格及特定标点（`’`, `—`, `$`, `,`, `.`, `?`），移除其他字符。
- **校验规则**：
    - 非空且长度不超过 600 字符。
    - 去重（避免重复录制相同内容）。

### **5. 音频录制 (`audio_recorder.py`)**

- **录制源**：使用 `soundcard` 库录制系统内部声音（Loopback），即“内录”。
- **智能控制**：
    - **自动开始**：检测到声音超过阈值（默认 -40dB）时开始保存数据。
    - **自动停止**：持续静音超过 1.5 秒或达到最大时长 30 秒。
- **后期处理**：
    - 音频归一化（Normalize）以提升音量。
    - 首尾添加 0.3 秒静音填充。
- **文件保存**：
    - 音频命名格式：`[清洗后文本]_[日期].wav`。
    - 同时保存对应的 `.txt` 文件用于“单词游戏”功能。
    - **触发变速生成**：录制完成后，自动调用 `audio_processor.py` 生成慢速版本。

### **6. 音频变速处理 (`audio_processor.py`)**

- **工具**：调用 `ffmpeg`。
- **算法**：优先使用 `rubberband` 滤镜（高保真），失败则降级使用 `atempo`。
- **输出**：生成 0.5 倍速和 0.75 倍速的副本，命名格式为 `[文本]@[速度]_[日期].wav`。

### **7. 前端交互 (`floating_ui.py`)**

- **界面**：基于 PyQt6 的悬浮窗，具备播放列表和控制按钮。
- **播放模式**：
    - **模式 1 (渐进模式)**：按顺序播放 0.5x -> 0.75x -> 1.0x 版本，帮助循序渐进听清细节。
    - **模式 2 (重复模式)**：循环播放原速 (1.0x) 音频 N 次（默认 3 次）。
- **列表逻辑**：自动扫描 `audio` 目录，通过文件名解析关联原速文件与其慢速副本。

---

### **关键数据流**

1. **用户操作**：鼠标选中一段英文 -> 拖拽/双击。
2. **程序响应**：
    - 自动复制文本并清洗。
    - 后台静默开启内录，等待 TTS 发音（需配合外部发音软件）。
    - 捕获声音 -> 保存 WAV -> 生成慢速 WAV。
3. **结果反馈**：前端悬浮窗刷新列表，用户可点击播放或自动复习。

---

prompt: 请总结设计文档，整理出程序的框架和关键细节，使用了哪些库，实现了什么样的用户功能，用纯文本输出

这是一份关于 **2026newReadingI** 程序的设计文档总结。

### 1. 程序框架

本程序采用模块化设计，主要由 **主控逻辑**、**输入监听**、**数据采集**、**数据处理** 和 **用户界面** 五个部分组成。

- **主控逻辑 (MainApp):** `main.py`
    - 程序的入口点，负责初始化各个子模块。
    - 协调事件响应循环，将用户的鼠标操作转化为具体的业务流程（触发 -> 抓取 -> 录制）。
- **用户界面 (UI):** `floating_ui.py`
    - 基于 **PyQt6** 构建。
    - 提供一个 **悬浮球 (Floating Ball)** 和 **侧边面板 (Panel)**。
    - 负责展示录制的音频列表、提供播放控制（播放/暂停/切换模式）以及配置反馈。
- **输入监听:**
    - 使用 `pynput` 实现全局鼠标事件钩子，监听用户的 **拖拽 (Drag)** 和 **双击 (Double Click)** 操作作为触发信号。
- **数据采集:**
    - **文本:** `clipboard_manager.py` 通过模拟 `Ctrl+C` 和 `pyperclip` 获取选中的文本。
    - **音频:** `audio_recorder.py` 使用 `soundcard` 库通过 **系统内录 (Loopback)** 方式捕获音频流。
- **数据处理:**
    - **文本处理:** `text_processor.py` 负责文本的清洗（仅保留英文字母和特定符号）与校验。
    - **音频处理:** `audio_processor.py` 调用外部 `ffmpeg` 工具生成不同倍速（0.5x, 0.75x）的音频变体。

### 2. 关键细节

- **触发机制:**
    - **拖拽触发:** 按下与释放点的距离 > 5 像素。
    - **双击触发:** 两次点击间隔 < 0.5 秒。
    - 触发后自动执行：备份剪贴板 -> 模拟复制 -> 获取文本 -> 恢复剪贴板 -> 启动录音监听。
- **智能录音:**
    - **静音检测:** 基于 RMS 振幅计算 dB，设定阈值（如 -40dB）自动开始和停止录音。
    - **自动裁剪:** 录音完成后自动去除首尾静音片段，并进行音量归一化处理。
- **音频变体生成:**
    - 录制完成后，程序会自动调用 `ffmpeg` 生成 0.5 倍速和 0.75 倍速的慢速版本，用于后续的跟读训练。
    - 优先使用 `rubberband` 滤镜以保证高音质，失败则回退到 `atempo` 滤镜。
- **文件命名规范:**
    - 格式：`[清洗后的文本]_[YYYY-MM-DD].wav`
    - 变体格式：`[清洗后的文本]@0.5_[YYYY-MM-DD].wav`

### 3. 使用的库 (Libraries)

- **PyQt6**: 用于构建图形用户界面（悬浮球、播放器、列表）。
- **pynput**: 用于监听全局鼠标事件和模拟键盘操作（Ctrl+C）。
- **soundcard**: 用于系统音频内录（WASAPI Loopback）。
- **soundfile**: 用于读取和保存 WAV 音频文件。
- **numpy**: 用于音频数据的数值计算（如 RMS 计算、归一化）。
- **pyperclip**: 用于剪贴板内容的读取和写入。
- **pywin32**: 提供 Windows 系统级 API 支持（如窗口管理）。
- **ffmpeg** (外部依赖): 用于音频的时间拉伸（变速不变调）处理。

### 4. 实现的用户功能

1. **所选即所录 (Select-to-Record):**
    - 用户只需在屏幕上选中一段英文文本并进行拖拽或双击，程序自动识别文本内容，并进入“听音”状态，等待用户播放对应的 TTS 语音（如在浏览器中播放），随后自动录制该段音频。
2. **辅助听力播放:**
    - **模式一 (渐进式):** 依次播放 0.5倍速 -> 0.75倍速 -> 原速音频，帮助用户循序渐进听清细节。
    - **模式二 (重复式):** 循环播放原速音频指定次数（如 5 次），用于强化记忆。
3. **音频管理:**
    - 通过悬浮窗查看历史录制记录，支持点击播放。
4. **单词/句子清洗:**
    - 自动过滤非英文字符，仅保留核心学习内容，避免标点符号或特殊格式干扰文件名和导致的文件名错误。

---

### 1. 程序框架

程序主要由以下五个核心模块组成：

- **主控逻辑 (MainApp):** `main.py`
    - 程序的“大脑”，负责初始化和状态管理。
    - 协调鼠标监听、剪贴板操作、文本处理和录音流程。
- **用户界面 (UI):** `floating_ui.py`
    - **悬浮球 (Floating Ball):** 常驻桌面的轻量级入口。
    - **列表面板 (ListPanel):** 展示录音历史。
    - **播放器 (AudioPlayer):** 负责音频的变体播放逻辑。
    - **游戏窗口 (WordGameWindow):** *[新增]* 独立的无边框窗口，用于运行单词拼句游戏。
- **输入监听:** `pynput` 监听全局鼠标事件（拖拽、双击）。
- **数据采集:**
    - **文本:** `clipboard_manager.py` (剪贴板)。
    - **音频:** `audio_recorder.py` (系统内录)。
- **数据处理:**
    - **文本:** `text_processor.py` (清洗/校验)。
    - **音频:** `audio_processor.py` (FFmpeg 变速处理)。

### 2. 关键细节

- **触发与录制流:**
    - 鼠标拖拽/双击 -> 自动复制选中文本 -> 清洗文本 -> 启动录音监听 -> (检测到声音) -> 录制 -> (检测到静音) -> 停止并保存。
- **游戏数据生成 (Game Data Gen):**
    - 在 `audio_recorder.py` 保存音频的同时，会将**清洗后的文本**同步保存为同名的 `.txt` 文件到 `text/` 目录下。
    - 这是游戏内容的数据来源。
- **单词还原游戏 (Word Puzzle Game):**
    - **触发条件:** 在历史列表中，如果某条录音对应的文本文件存在且长度 > 30 个字符（可配置），该条目即变为“可玩状态”（通常表现为文件名可点击）。
    - **分词算法:** 将句子智能拆解为单词、数字、缩写（如 `it's`）和标点符号。
    - **乱序逻辑:** 随机打乱单词顺序，并确保打乱后的序列与原句不同。
    - **交互:** 用户点击下方的乱序单词，将其移动到上方目标区域；点击上方单词可撤回。
    - **校验:** 当还原的单词数量与原句一致时，自动校验顺序。如果完全匹配，显示“回答正确”并自动关闭。
- **音频变体:**
    - 生成 0.5x 和 0.75x 的慢速音频，用于渐进式听力训练。

### 3. 使用的库 (Libraries)

- **PyQt6**: 核心 UI 框架（悬浮球、游戏窗口、动画）。
- **pynput**: 鼠标/键盘事件监听与模拟。
- **soundcard** & **soundfile**: 音频内录与文件读写。
- **numpy**: 音频数据处理（RMS 计算、静音检测）。
- **pyperclip**: 剪贴板操作。
- **ffmpeg** (外部工具): 音频变速处理。
- **re** (标准库): 正则表达式，用于文本清洗和游戏分词。

### 4. 实现的用户功能

1. **所选即所录 (Select-to-Record):**
    - 极简交互：拖拽或双击文本即可触发“听音录制”模式，自动捕获 TTS 发音。
2. **单词还原拼句游戏 (Sentence Scramble Game):**
    - **寓教于乐:** 针对长难句（>30字符），提供拼句游戏功能。
    - **强化记忆:** 用户需要将打乱的单词还原成正确的句子，通过主动输出来强化对句子结构的掌握。
3. **分级听力训练:**
    - **渐进模式:** 自动按 0.5x -> 0.75x -> 1.0x 的顺序播放，适应不同听力水平。
    - **重复模式:** 对原速音频进行循环播放，进行“磨耳朵”训练。
4. **可视化历史管理:**
    - 通过悬浮球快速访问最近录制的句子，随时回听或开始游戏。

