# 项目重构需求：引入 SQLite 数据库

## 一、项目背景

本项目是一个 Windows 桌面语言学习辅助工具。核心功能包括：

- 后台监听用户选中文本，自动录制系统发音
- 生成 1 倍速、0.5 倍速、0.75 倍速三个版本的音频文件
- 悬浮窗口 UI 管理和播放录音文件
- 单词还原句子游戏功能

当前版本通过文件名存储元数据（名称、日期），通过 text 文件夹中的 txt 文件存储原始文本内容。现需重构为 SQLite 数据库方案，提升数据管理能力并为后续功能扩展做准备。

## 二、数据库设计

### 2.1 数据库文件

- 文件名：data.db
- 存放位置：项目根目录
- 数据库引擎：SQLite

### 2.2 表结构设计

创建名为 recordings 的数据表，包含以下字段：

| 字段名 | 数据类型 | 约束 | 说明 |
| --- | --- | --- | --- |
| number | INTEGER | PRIMARY KEY AUTOINCREMENT | 唯一标识符，自增，删除后不复用 |
| name | TEXT | NOT NULL | 显示名称，即清洗后的文本（用于列表显示） |
| content | TEXT |  | 原始完整文本（用于单词还原游戏） |
| remember | INTEGER | DEFAULT 0 | 预留字段，暂不使用 |
| forget | INTEGER | DEFAULT 0 | 预留字段，暂不使用 |
| date | DATE | NOT NULL | 录音日期，格式 YYYY-MM-DD |

### 2.3 建表语句

```sql
CREATE TABLE IF NOT EXISTS recordings (
    number INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    content TEXT,
    remember INTEGER DEFAULT 0,
    forget INTEGER DEFAULT 0,
    date DATE NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_date ON recordings(date);
```

## 三、音频文件命名规则

基于数据库 number 字段设计简洁的纯数字文件命名格式：

- 1 倍速文件：`{number}.wav`
- 0.75 倍速文件：`{number}@0.75.wav`
- 0.5 倍速文件：`{number}@0.5.wav`

示例：若 number 为 42，则文件名为：

- `42.wav`
- `42@0.75.wav`
- `42@0.5.wav`

数据库仅存储主文件信息（number、name、content、date），变速文件通过命名规则推导，无需单独存储。文件名不再包含 name 和 date 信息，这些元数据完全由数据库管理。

## 四、文件识别机制变更

将现有所有通过文件名识别文件的逻辑，全部改为通过 number 字段识别。

具体包括：

- 列表加载时通过 number 匹配数据库记录和音频文件
- 播放时通过 number 定位 1 倍速、0.5 倍速、0.75 倍速文件
- 删除时通过 number 删除相关的三个音频文件和数据库记录
- 日期筛选通过数据库 date 字段查询，而非解析文件名

## 五、录音保存流程重构

### 5.1 事务处理要求

录音保存时，数据库写入和文件保存必须作为一个原子事务处理：

1. 开始事务
2. 向数据库插入新记录，获取自增的 number 值
3. 根据 number 生成文件名，保存 1 倍速音频文件
4. 生成并保存 0.75 倍速音频文件
5. 生成并保存 0.5 倍速音频文件
6. 提交事务

### 5.2 回滚机制

若上述任一步骤失败：

- 回滚数据库事务，撤销插入的记录
- 尝试删除已生成的任何音频文件
- 若文件删除失败（如文件被占用、权限不足），记录警告日志但不阻塞流程
- 在控制台输出错误信息，包含失败原因和未能删除的文件路径
- 录音流程终止，不影响程序继续运行

### 5.3 回滚日志格式

- 事务回滚：`Recording save failed: {错误原因}, transaction rolled back`
- 文件删除成功：`Rollback cleanup: deleted {文件路径}`
- 文件删除失败：`Rollback cleanup warning: failed to delete {文件路径}, reason: {原因}`

## 六、多进程并发安全策略

本项目采用多进程架构：后台录音进程（[main.py](http://main.py)）和 UI 进程（floating_[ui.py](http://ui.py)）独立运行，可能同时访问数据库，需保证并发安全。

### 6.1 连接管理

- 每个进程维护独立的数据库连接
- 启用 SQLite 的 WAL（Write-Ahead Logging）模式提升并发性能
- 使用 `PRAGMA busy_timeout=30000` 设置 30 秒超时，避免死锁

### 6.2 读写策略

- WAL 模式下，读操作不阻塞写操作，写操作不阻塞读操作
- 同一时刻只有一个进程能执行写操作，其他写操作会等待直到超时
- 写操作失败时进行有限次数的重试（默认 3 次）

### 6.3 进程职责划分

- **后台进程（[main.py](http://main.py)）负责**：插入新记录、保存音频文件
- **UI 进程（floating_[ui.py](http://ui.py)）负责**：查询列表、删除记录、更新 remember/forget 字段（预留）、启动时一致性校验

### 6.4 进程间通信

两个进程通过 Socket 进行状态协调：

- Socket 65432：UI 作为 Server。后台录音完成后发送通知消息，UI 收到通知后主动查询数据库刷新列表
- Socket 65433：后台作为 Server。UI 退出时发送退出指令

Socket 消息仅作为事件通知，不传递具体数据，所有数据交换通过数据库完成。

## 七、启动时一致性校验

程序启动时，由 UI 进程执行 audio 目录与数据库的一致性校验。

### 7.1 校验执行进程

- 一致性校验由 UI 进程（floating_[ui.py](http://ui.py)）独占执行
- 校验期间，UI 进程持有数据库写锁
- 后台进程在校验完成前，若尝试写入数据库会等待（由 busy_timeout 控制）

### 7.2 校验逻辑

遍历数据库所有记录，检查对应的 1 倍速音频文件（`{number}.wav`）是否存在于 audio 目录中。同时遍历 audio 目录所有 1 倍速文件（不含 @0.5 和 @0.75 的文件），检查是否有对应的数据库记录。

### 7.3 不一致处理策略

发现任何不一致时，采用清除策略，每个清除操作作为独立事务：

- 数据库有记录但 audio 文件不存在：删除该数据库记录（独立事务）
- audio 有文件但数据库无对应记录：删除该音频文件及其变速版本（独立操作）
- 若某个清除操作失败，记录日志并继续处理下一个不一致项

### 7.4 控制台输出

- 校验开始：`Consistency check started`
- 发现孤立记录：`Consistency check: removing orphan record number={number}`
- 发现孤立文件：`Consistency check: removing orphan file {文件名}`
- 单项清理失败：`Consistency check warning: failed to remove {记录/文件}, reason: {原因}`
- 校验完成：`Consistency check completed, removed {X} records and {Y} files`

## 八、UI 列表显示适配

### 8.1 列表数据来源

列表内容改为从数据库查询获取，而非扫描文件系统。

查询逻辑：

- 根据当前选中的日期筛选条件，查询 date 字段匹配的记录
- 按 number 倒序排列（最新录音显示在最上方）
- 列表项显示 name 字段内容，number 字段对用户不可见但用于内部定位文件

### 8.2 日期筛选适配

- 日期下拉列表的选项从数据库查询：`SELECT DISTINCT date FROM recordings ORDER BY date DESC LIMIT 15`
- 当天日期显示为 Today，其他日期显示为 YY/MM/DD 格式
- 选中某日期后，列表内容通过 SQL 查询筛选：`SELECT number, name FROM recordings WHERE date = ? ORDER BY number DESC`

### 8.3 空状态处理

- 若数据库无任何记录，显示提示文字
- 若选中日期无对应记录，显示今天没有录音的提示

### 8.4 列表刷新机制

- UI 进程通过 Socket 65432 接收后台进程的录音完成通知
- 收到通知后，UI 主动查询数据库获取最新数据并刷新列表
- Socket 消息仅作为触发信号，不携带具体录音数据

## 九、单词还原句子游戏适配

### 9.1 可游戏判定条件

将原有判定逻辑从读取 txt 文件字符数，改为查询数据库：

- 查询条件：`LENGTH(COALESCE(content, '')) > 30`
- 满足条件的记录对应的列表项显示为可点击状态

### 9.2 游戏数据获取

点击可游戏的列表项时：

- 通过 number 查询数据库获取 content 字段内容
- 将 content 内容传递给游戏逻辑进行分词和打乱

## 十、自动清理机制适配

### 10.1 清理触发条件

保持原有逻辑：程序启动后等待 60 秒，检测有录音的日期数量是否超过 15 个。

### 10.2 清理执行逻辑

使用数据库查询替代文件扫描：

1. 查询所有不重复的日期并按日期升序排列
2. 若日期数量超过 15 个，计算需要清理的旧日期列表
3. 对每个需要清理的日期，查询该日期的所有记录
4. 对每条记录执行独立的清理事务：
    - 删除该记录对应的三个音频文件（1 倍速、0.75 倍速、0.5 倍速）
    - 删除数据库记录
    - 若文件删除失败，记录警告日志并继续处理下一条
5. 单条记录的清理失败不影响其他记录的清理

### 10.3 控制台输出

- 清理开始：`Cleanup started, found {X} dates exceeding limit of 15`
- 清理单条记录：`Cleanup: removed record number={number} for date {YYYY-MM-DD}`
- 文件删除失败：`Cleanup warning: failed to delete file {文件名}, reason: {原因}`
- 清理完成：`Cleanup completed, removed {X} records`

## 十一、删除功能适配

### 11.1 单条删除

用户通过右键菜单或 Ctrl+左键删除某条记录时：

1. 获取该行对应的 number
2. 若该条目正在播放，先停止播放
3. 删除 audio 目录中的三个音频文件
4. 删除数据库中 number 对应的记录
5. 立即刷新列表

### 11.2 容错处理

- 若某个音频文件删除失败，记录警告日志但继续删除其他文件和数据库记录
- 数据库记录删除成功即视为删除完成

### 11.3 控制台输出

- 删除成功：`Delete: removed record number={number}`
- 文件删除失败：`Delete warning: failed to delete file {文件名}, reason: {原因}`

## 十二、text 文件夹处理

- 删除项目中的 text 文件夹
- 移除所有与 text 文件夹相关的代码逻辑
- 原本写入 txt 文件的内容改为写入数据库 content 字段

## 十三、配置文件更新

在 config.ini 中新增 Database 配置区域：

```
[Database]
db_path = data.db
wal_mode = true
busy_timeout = 30000
retry_count = 3
```

参数说明：

- `db_path`：数据库文件路径，默认值为项目根目录下的 data.db
- `wal_mode`：是否启用 WAL 模式，默认值 true
- `busy_timeout`：数据库操作超时时间（毫秒），默认值 30000
- `retry_count`：写操作失败重试次数，默认值 3

## 十四、迁移说明

- 不考虑现有录音和文本文件的迁移
- audio 文件夹和 text 文件夹已清空
- 首次启动时自动创建数据库文件和表结构（包括索引）
- 若数据库文件已存在则直接使用，不重复创建表

## 十五、验收标准

1. 程序启动时自动创建 data.db 数据库文件和 recordings 表及索引
2. 录音保存后数据正确写入数据库，音频文件命名符合新规则（如 `42.wav`）
3. 列表正确显示 name 字段内容，日期筛选功能正常
4. 单词还原游戏功能基于数据库 content 字段正常运作
5. 删除功能同步删除数据库记录和音频文件
6. 启动时一致性校验由 UI 进程执行，正常清理不一致数据
7. 超期文件自动清理功能正常运作，每条记录独立事务处理
8. 多进程并发操作时无数据损坏或崩溃
9. text 文件夹相关代码完全移除
10. 回滚和清理操作的日志输出符合规范


## 删除 name 字段

请执行以下代码修改任务，删除数据库中的 `name` 字段，统一使用 `content` 字段。

### 任务背景

当前 `recordings` 表中 `name` 和 `content` 字段存储了完全相同的内容，需要删除冗余的 `name` 字段。UI 层已通过 `ui_max_filename_chars` 配置项在显示时进行截断，无需数据库层面维护单独的显示名称。

### 修改文件清单

1. `db_[manager.py](http://manager.py)`
2. `floating_[ui.py](http://ui.py)`
3. `audio_[recorder.py](http://recorder.py)`

### 具体修改要求

**文件 1：db_[manager.py](http://manager.py)**

1. 修改 `init_db` 方法中的建表语句：
    - 删除 `name TEXT NOT NULL` 字段
    - 将 `content TEXT` 改为 `content TEXT NOT NULL`
2. 修改 `insert_recording` 方法：
    - 方法签名从 `insert_recording(self, name, content, date_str)` 改为 `insert_recording(self, content, date_str)`
    - SQL 语句从 `INSERT INTO recordings (name, content, date) VALUES (?, ?, ?)` 改为 `INSERT INTO recordings (content, date) VALUES (?, ?)`
    - 参数从 `(name, content, date_str)` 改为 `(content, date_str)`
3. 修改 `get_recordings_by_date` 方法：
    - SQL 语句从 `SELECT number, name, content, date FROM recordings...` 改为 `SELECT number, content, date FROM recordings...`

**文件 2：floating_[ui.py](http://ui.py)**

1. 修改 `AudioListItem` 类的 `__init__` 方法：
    - 删除 [`self.name](http://self.name) = recording_data['name']` 这一行
2. 修改 `AudioListItem` 类的 `init_ui` 方法：
    - 将 `display_text = [self.name](http://self.name)` 改为 `display_text = self.content`
    - 将 `self.label.setToolTip([self.name](http://self.name))` 改为 `self.label.setToolTip(self.content)`

**文件 3：audio_[recorder.py](http://recorder.py)**

1. 找到调用 `db_manager.insert_recording` 的位置
2. 将调用从 `insert_recording(name, content, date_str)` 改为 `insert_recording(content, date_str)`
3. 删除不再使用的 `name` 变量相关代码（如果有）

### 迁移处理

完成代码修改后，手动删除项目根目录下的 `data.db` 文件，程序启动时会自动创建新的表结构。

### 注意事项

- 不要修改任何其他逻辑，仅删除 `name` 字段相关代码
- 保持 `content` 的所有现有用法不变（游戏判定、游戏内容传递）
- UI 显示截断逻辑保持不变

### 验证标准

1. 程序能正常启动，自动创建新的数据库表结构
2. 录音保存正常，数据库中无 `name` 字段
3. 列表正确显示 `content` 内容（超长时截断加 "...")
4. tooltip 显示完整的 `content` 内容
5. 单词还原游戏功能正常